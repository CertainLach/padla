## @vtlvariable name="packageName" type="java.lang.String"
## @vtlvariable name="className" type="java.lang.String"
## @vtlvariable name="unsafeClassName" type="java.lang.String"
## @vtlvariable name="importedClasses" type="java.lang.String[]"
## @vtlvariable name="unsafeMethods" type="ru.progrm_jarvis.padla.tools.unsafemethodsaccessgenerator.UnsafeMethodData[]"
#if (${packageName} && !${packageName.equals("")})package ${packageName};

#end##
import lombok.SneakyThrows;
import lombok.experimental.UtilityClass;
import lombok.val;
import ru.progrm_jarvis.javacommons.invoke.InvokeUtil;

#foreach(${importedClass} in ${importedClasses})
import ${importedClass};
#end

import java.lang.invoke.MethodHandle;

import static java.lang.invoke.MethodType.methodType;

@UtilityClass
public class ${className} {

    private final MethodHandle
#foreach(${method} in ${unsafeMethods})
    UNSAFE_${method.upperCamelCaseNameWithTypeInfo}_METHOD#if(${foreach.hasNext}),#else;#end

#end

    private final boolean USE_SUN_MISC_UNSAFE;

    static {
        final Class<?> unsafeClass;
        {
            boolean useSunMiscUnsafe = false;
            {
                Class<?> sunMiscUnsafeClass;
                try {
                    sunMiscUnsafeClass = Class.forName("sun.misc.Unsafe");
                    useSunMiscUnsafe = true;
                } catch (final ClassNotFoundException e) {
                    sunMiscUnsafeClass = null;
                }

                if (!useSunMiscUnsafe) try {
                    unsafeClass = Class.forName("jdk.internal.misc.Unsafe");
                    useSunMiscUnsafe = false;
                } catch (final ClassNotFoundException classNotFoundException) {
                    throw new RuntimeException("Could not find Unsafe class");
                } else unsafeClass = sunMiscUnsafeClass;
            }
            USE_SUN_MISC_UNSAFE = useSunMiscUnsafe;
        }
        val unsafeClassLookup = InvokeUtil.lookup(unsafeClass);

        try {
#foreach(${unsafeMethod} in ${unsafeMethods})
            UNSAFE_${unsafeMethod.upperCamelCaseNameWithTypeInfo}_METHOD = unsafeClassLookup.findVirtual(
                        unsafeClass, "${unsafeMethod.method.name}", methodType(unsafeClass#foreach(${parameterType} in ${unsafeMethod.signature}), ${parameterType}.class#end)
            );
#end##
        } catch (final NoSuchMethodException | IllegalAccessException e) {
            throw new IllegalStateException("Could not find Unsafe method", e);
        }
    }

#foreach(${unsafeMethod} in ${unsafeMethods})

    @SneakyThrows
    public ${unsafeMethod.returnType} ${unsafeMethod.method.name}(sun.misc.Unsafe unsafe##
#foreach(${parameterType} in ${unsafeMethod.signature}), final ${parameterType} p${foreach.index}#end) {
        if (USE_SUN_MISC_UNSAFE) #if(${unsafeMethod.returnValue})return #{end}SunMiscUnsafeWrapper.${unsafeMethod.method.name}(unsafe#foreach(${parameterType} in ${unsafeMethod.signature}), p${foreach.index}#end);
        #if(${unsafeMethod.returnValue})return#{else}else#{end} JdkInternalMiscUnsafeWrapper.${unsafeMethod.method.name}(unsafe#foreach(${parameterType} in ${unsafeMethod.signature}), p${foreach.index}#end);
    }
#end

    private static final class SunMiscUnsafeWrapper {
#foreach(${unsafeMethod} in ${unsafeMethods})

        @SneakyThrows
        public static ${unsafeMethod.returnType} ${unsafeMethod.method.name}(final Object unsafe##
#foreach(${parameterType} in ${unsafeMethod.signature}), final ${parameterType} p${foreach.index}#end) {
            #if(${unsafeMethod.returnValue})return (${unsafeMethod.returnType}) #{end}UNSAFE_${unsafeMethod.upperCamelCaseNameWithTypeInfo}_METHOD.invokeExact((sun.misc.Unsafe) unsafe#foreach(${parameterType} in ${unsafeMethod.signature}), p${foreach.index}#end);
        }
#end
    }

    private static final class JdkInternalMiscUnsafeWrapper {
#foreach(${unsafeMethod} in ${unsafeMethods})

        @SneakyThrows
        public static ${unsafeMethod.returnType} ${unsafeMethod.method.name}(final Object unsafe##
#foreach(${parameterType} in ${unsafeMethod.signature}), final ${parameterType} p${foreach.index}#end) {
            #if(${unsafeMethod.returnValue})return (${unsafeMethod.returnType}) #{end}UNSAFE_${unsafeMethod.upperCamelCaseNameWithTypeInfo}_METHOD.invokeExact((jdk.internal.misc.Unsafe) unsafe#foreach(${parameterType} in ${unsafeMethod.signature}), p${foreach.index}#end);
        }
#end
    }
}
